#include "RuleGenerator.h"
#include <QJsonDocument>
#include <QJsonArray>
#include <QFile>
#include <grp.h>

namespace udevme {

bool RuleGenerator::checkPlugdevGroup() {
    struct group* grp = getgrnam("plugdev");
    return grp != nullptr;
}

QString RuleGenerator::generateMetadataComment(const UdevRule& rule) {
    // Generate structured comment for parsing back
    // Notes are stored separately in notes.json, not in the rules file
    QStringList deviceParts;
    for (const auto& d : rule.devices) {
        deviceParts << QString("%1:%2").arg(d.vendorId, d.productId);
    }
    
    QStringList appParts;
    for (const auto& a : rule.applications) {
        appParts << a.desktopId;
    }
    
    QStringList typeParts;
    if (rule.ruleTypes.hidraw) typeParts << "hidraw";
    if (rule.ruleTypes.usb) typeParts << "usb";
    if (rule.ruleTypes.uaccess) typeParts << "uaccess";
    if (rule.ruleTypes.seat) typeParts << "seat";
    
    QString comment = QString("# udevme: id=%1 devices=%2 apps=%3 level=%4 types=%5 enabled=%6")
        .arg(rule.id.toString(QUuid::WithoutBraces))
        .arg(deviceParts.join(","))
        .arg(appParts.isEmpty() ? "all" : appParts.join(","))
        .arg(permissionLevelToString(rule.permissionLevel))
        .arg(typeParts.join(","))
        .arg(rule.enabled ? "true" : "false");
    
    return comment;
}

QString RuleGenerator::generatePermissionPart(const UdevRule& rule) {
    Q_UNUSED(rule);
    // Standard WebHID permissions - MODE 0666 + uaccess + seat for maximum compatibility
    return "MODE=\"0666\", TAG+=\"uaccess\", TAG+=\"seat\"";
}

QString RuleGenerator::generateSingleRule(const UdevRule& rule) {
    if (rule.devices.isEmpty()) {
        return QString();
    }
    
    QString output;
    output += generateMetadataComment(rule) + "\n";
    
    for (const auto& device : rule.devices) {
        // Generate hidraw rule for WebHID
        QString hidrawRule = QString(
            "KERNEL==\"hidraw*\", SUBSYSTEM==\"hidraw\", "
            "ATTRS{idVendor}==\"%1\", ATTRS{idProduct}==\"%2\", %3")
            .arg(device.vendorId.toLower())
            .arg(device.productId.toLower())
            .arg(generatePermissionPart(rule));
        output += hidrawRule + "\n";
    }
    
    return output;
}

QString RuleGenerator::generateRulesFile(const QVector<UdevRule>& rules) {
    QString output;
    
    // File header
    output += "# udevme - Auto-generated udev rules for WebHID / hidraw device access\n";
    output += "# Generated by udevme\n";
    output += "# Do not edit manually - changes will be overwritten\n";
    output += "#\n";
    output += "# File format version: 1\n";
    output += "# schema_version=1\n";
    output += "\n";
    
    // Generate rules for enabled rules only
    int count = 0;
    for (const auto& rule : rules) {
        if (!rule.enabled) continue;
        if (rule.devices.isEmpty()) continue;
        
        QString ruleText = generateSingleRule(rule);
        if (!ruleText.isEmpty()) {
            output += ruleText + "\n";
            count++;
        }
    }
    
    if (count == 0) {
        output += "# No enabled rules configured\n";
    }
    
    return output;
}

} // namespace udevme
